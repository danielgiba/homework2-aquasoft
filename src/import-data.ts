//scope: import data csv->pg db
import fs from 'fs';
import path from 'path';
import csv from 'csv-parser';
import dotenv from 'dotenv';
import { Sequelize } from 'sequelize';
import { City, Region, Hotel } from '../models';

dotenv.config();
//conn sequelize w/ pg variables
const sequelize = new Sequelize(
  process.env.DB_NAME!,
  process.env.DB_USERNAME!,
  process.env.DB_PASSWORD!,
  {
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    dialect: 'postgres',
    logging: false,
  }
);

const csvFilePath = path.join(
  __dirname,
  '../All CSL Properties with Global Ids and GDS Ids (Active)_Jun25_1.csv'
);

const uniqueCities = new Map();
const uniqueRegions = new Map();
const hotels: any[] = [];

let autoGeneratedHotelId = 1000000;
//constr data from csv for pg(for tables)
fs.createReadStream(csvFilePath)
  .pipe(csv({ separator: '\t' }))
  .on('data', (row) => {
    const city = row['Property City Name']?.trim();
    const country = row['Property Country Code']?.trim();
    const region = row['Property State/Province']?.trim();

    const rawID = parseInt(row['Global Property ID']);
    const globalID = isNaN(rawID) ? autoGeneratedHotelId++ : rawID;

    const hotel = {
      GlobalPropertyID: globalID,
      SourcePropertyID: row['Source Property ID'],
      GlobalPropertyName: row['Global Property Name'],
      GlobalChainCode: row['Global Chain Code'],
      PropertyAddress1: row['Property Address 1'],
      PropertyAddress2: row['Property Address 2'],
      PrimaryAirportCode: row['Primary Airport Code'],
      PropertyZipPostal: row['Property Zip/Postal'],
      PropertyPhoneNumber: row['Property Phone Number'],
      PropertyFaxNumber: row['Property Fax Number'],
      SabrePropertyRating: parseFloat(row['Sabre Property Rating'] || '0'),
      PropertyLatitude: parseFloat(row['Property Latitude'] || '0'),
      PropertyLongitude: parseFloat(row['Property Longitude'] || '0'),
      SourceGroupCode: row['Source Group Code'],
      rawCity: city,
      rawCountry: country,
      rawRegion: region,
    };

    if (city && country) {
      const key = `${city}|${country}`;
      if (!uniqueCities.has(key)) {
        uniqueCities.set(key, {
          CityID: uniqueCities.size + 1,
          CityName: city,
          Country: country,
        });
      }
    }

    if (region) {
      if (!uniqueRegions.has(region)) {
        uniqueRegions.set(region, {
          PropertyStateProvinceID: uniqueRegions.size + 1,
          PropertyStateProvinceName: region,
        });
      }
    }

    hotels.push(hotel);
  })
  //inserations
  .on('end', async () => {
    try {
      const cityMap = new Map();
      const regionMap = new Map();
      //inser Cities in og
      for (const city of uniqueCities.values()) {
        const [createdCity] = await City.upsert({
          CityID: city.CityID,
          CityName: city.CityName,
          Country: city.Country,
          createdAt: new Date(),
          updatedAt: new Date(),
        });
        cityMap.set(`${city.CityName}|${city.Country}`, city.CityID);
      }
      //insert Regions in pg
      for (const region of uniqueRegions.values()) {
        const [createdRegion] = await Region.upsert({
          PropertyStateProvinceID: region.PropertyStateProvinceID,
          PropertyStateProvinceName: region.PropertyStateProvinceName,
          createdAt: new Date(),
          updatedAt: new Date(),
        });
        regionMap.set(region.PropertyStateProvinceName, region.PropertyStateProvinceID);
      }
      //insert Hotels in pg
      for (const hotel of hotels) {
        const CityID = cityMap.get(`${hotel.rawCity}|${hotel.rawCountry}`) || null;
        const RegionID = regionMap.get(hotel.rawRegion) || null;

        await Hotel.upsert({
          GlobalPropertyID: hotel.GlobalPropertyID,
          SourcePropertyID: hotel.SourcePropertyID,
          GlobalPropertyName: hotel.GlobalPropertyName,
          GlobalChainCode: hotel.GlobalChainCode,
          PropertyAddress1: hotel.PropertyAddress1,
          PropertyAddress2: hotel.PropertyAddress2,
          PrimaryAirportCode: hotel.PrimaryAirportCode,
          CityID,
          PropertyStateProvinceID: RegionID,
          PropertyZipPostal: hotel.PropertyZipPostal,
          PropertyPhoneNumber: hotel.PropertyPhoneNumber,
          PropertyFaxNumber: hotel.PropertyFaxNumber,
          SabrePropertyRating: hotel.SabrePropertyRating,
          PropertyLatitude: hotel.PropertyLatitude,
          PropertyLongitude: hotel.PropertyLongitude,
          SourceGroupCode: hotel.SourceGroupCode,
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        //console.log(`imported hotel FOR TESTING => ${hotel.GlobalPropertyName}`);
      }

      console.log('imported succesfully!');
      process.exit(0);
    } catch (error) {
      console.error('error at taking data ->', error);
      process.exit(1);
    }
  });
